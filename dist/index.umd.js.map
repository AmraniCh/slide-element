{"version":3,"file":"index.umd.js","sources":["../src/index.ts"],"sourcesContent":["import { Options, HeightValues, CallbackFunction } from \"./types\";\n\nconst defaultOptions: Options = {\n  duration: 0.25,\n  timingFunction: \"ease\",\n};\n\n/**\n * Add transition event listeners to given element.\n */\nconst addEventListeners = (\n  element: HTMLElement,\n  callback: CallbackFunction\n): void => {\n  element.addEventListener(\"transitionend\", callback);\n  element.addEventListener(\"transitioncancel\", callback);\n};\n\n/**\n * Remove transition event listeners from given element.\n */\nconst removeEventListeners = (\n  element: HTMLElement,\n  callback: CallbackFunction\n): void => {\n  element.removeEventListener(\"transitionend\", callback);\n  element.removeEventListener(\"transitioncancel\", callback);\n};\n\n/**\n * Fire a one-time function when an animation has completed.\n */\nconst waitForAnimationCompletion = (element: HTMLElement): Promise<void> => {\n  return new Promise((resolve) => {\n    const eventListenerCallback = function (e: TransitionEvent): void {\n      removeEventListeners(element, eventListenerCallback);\n      resolve();\n    };\n\n    addEventListeners(element, eventListenerCallback);\n  });\n};\n\n/**\n * Reset the given style properties on an element.\n */\nconst unsetProperties = (\n  element: HTMLElement,\n  properties: Array<string>\n): void => {\n  properties.forEach((p: string) => (element.style[p] = \"\"));\n};\n\n/**\n * Set initial CSS required to perform height transition.\n */\nconst setTransitionProperties = (\n  element: HTMLElement,\n  options: Options\n): void => {\n  const computedStyle = getStyles(element);\n  const { duration, timingFunction } = options;\n  const animationStyles = {\n    overflow: \"hidden\",\n    transitionProperty: \"height\",\n    transitionDuration: `${duration}s`,\n    transitionTimingFunction: timingFunction,\n  };\n\n  /**\n   * Set these properties only if they aren't already set. If we blindly set them every run,\n   * the animation will not work as expected because a reflow is triggered.\n   */\n  for (let k in animationStyles) {\n    if (computedStyle[k] === animationStyles[k]) {\n      delete animationStyles[k];\n    }\n  }\n\n  Object.assign(element.style, animationStyles);\n};\n\n/**\n * Retrieve the computed styles for an element.\n */\nconst getStyles = (element: HTMLElement): CSSStyleDeclaration => {\n  return window.getComputedStyle(element);\n};\n\n/**\n * Given a bunch of before/after property values, trigger a CSS animation\n * before & after the next repaint.\n */\nconst triggerAnimation = (\n  element: HTMLElement,\n  options: object,\n  heightValues: HeightValues,\n  callback: () => any\n): void => {\n  const { from, to } = heightValues;\n  waitForAnimationCompletion(element).then(() => {\n    unsetProperties(element, [\n      \"height\",\n      \"overflow\",\n      \"transitionProperty\",\n      \"transitionDuration\",\n      \"transitionTimingFunction\",\n    ]);\n\n    callback();\n  });\n\n  element.style.height = from;\n\n  setTransitionProperties(element, options);\n\n  // This update must happen on a separate tick in order to trigger an animation.\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      element.style.height = to;\n    });\n  });\n};\n\n/**\n * Animate an element open.\n */\nexport const down = (\n  element: HTMLElement,\n  options = defaultOptions\n): Promise<boolean> => {\n  return new Promise((resolve) => {\n    element.dataset.isSlidOpen = \"true\";\n    element.style.display = \"block\";\n    const computedStyles = getStyles(element);\n    triggerAnimation(\n      element,\n      options,\n      {\n        from: \"0px\",\n        to: computedStyles.height,\n      },\n      () => {\n        resolve(true);\n      }\n    );\n  });\n};\n\n/**\n * Animate an element closed.\n */\nexport const up = (element, options = defaultOptions): Promise<boolean> => {\n  return new Promise((resolve) => {\n    const computedStyles = getStyles(element);\n    triggerAnimation(\n      element,\n      options,\n      {\n        from: computedStyles.height,\n        to: \"0px\",\n      },\n      () => {\n        delete element.dataset.isSlidOpen;\n        element.style.display = \"none\";\n        resolve(false);\n      }\n    );\n  });\n};\n\n/**\n * Animate an element open or closed based on its state.\n */\nexport const toggle = (\n  element: HTMLElement,\n  options = defaultOptions\n): Promise<boolean> => {\n  return element.dataset.isSlidOpen\n    ? up(element, options)\n    : down(element, options);\n};\n"],"names":["defaultOptions","duration","timingFunction","getStyles","element","window","getComputedStyle","triggerAnimation","options","heightValues","callback","from","to","Promise","resolve","addEventListener","addEventListeners","eventListenerCallback","e","removeEventListener","removeEventListeners","waitForAnimationCompletion","then","properties","forEach","p","style","unsetProperties","height","computedStyle","animationStyles","overflow","transitionProperty","transitionDuration","transitionTimingFunction","k","Object","assign","setTransitionProperties","requestAnimationFrame","down","dataset","isSlidOpen","display","computedStyles","up"],"mappings":"sOAEA,IAAMA,EAA0B,CAC9BC,SAAU,IACVC,eAAgB,QAiFZC,EAAY,SAACC,GACjB,OAAOC,OAAOC,iBAAiBF,IAO3BG,EAAmB,SACvBH,EACAI,EACAC,EACAC,GAEA,IAAQC,EAAaF,EAAbE,KAAMC,EAAOH,EAAPG,IAnEmB,SAACR,GAClC,WAAWS,QAAQ,SAACC,IAvBI,SACxBV,EACAM,GAEAN,EAAQW,iBAAiB,gBAAiBL,GAC1CN,EAAQW,iBAAiB,mBAAoBL,GAwB3CM,CAAkBZ,EALY,SAAxBa,EAAkCC,IAbf,SAC3Bd,EACAM,GAEAN,EAAQe,oBAAoB,gBAAiBT,GAC7CN,EAAQe,oBAAoB,mBAAoBT,GAS5CU,CAAqBhB,EAASa,GAC9BH,SAgEJO,CAA2BjB,GAASkB,KAAK,YAtDnB,SACtBlB,EACAmB,GAqD2B,CACvB,SACA,WACA,qBACA,qBACA,4BAxDOC,QAAQ,SAACC,UAAerB,EAAQsB,MAAMD,GAAK,KAmDpDE,CAAgBvB,GAQhBM,MAGFN,EAAQsB,MAAME,OAASjB,EAxDO,SAC9BP,EACAI,GAEA,IAAMqB,EAAgB1B,EAAUC,GAE1B0B,EAAkB,CACtBC,SAAU,SACVC,mBAAoB,SACpBC,mBAJmCzB,EAA7BP,aAKNiC,yBALmC1B,EAAnBN,gBAYlB,IAAK,IAAIiC,KAAKL,EACRD,EAAcM,KAAOL,EAAgBK,WAChCL,EAAgBK,GAI3BC,OAAOC,OAAOjC,EAAQsB,MAAOI,GAmC7BQ,CAAwBlC,EAASI,GAGjC+B,sBAAsB,WACpBA,sBAAsB,WACpBnC,EAAQsB,MAAME,OAAShB,OAQhB4B,EAAO,SAClBpC,EACAI,GAEA,gBAFAA,IAAAA,EAAUR,OAECa,QAAQ,SAACC,GAClBV,EAAQqC,QAAQC,WAAa,OAC7BtC,EAAQsB,MAAMiB,QAAU,QACxB,IAAMC,EAAiBzC,EAAUC,GACjCG,EACEH,EACAI,EACA,CACEG,KAAM,MACNC,GAAIgC,EAAehB,QAErB,WACEd,GAAQ,QASH+B,EAAK,SAACzC,EAASI,GAC1B,gBAD0BA,IAAAA,EAAUR,OACzBa,QAAQ,SAACC,GAClB,IAAM8B,EAAiBzC,EAAUC,GACjCG,EACEH,EACAI,EACA,CACEG,KAAMiC,EAAehB,OACrBhB,GAAI,OAEN,kBACSR,EAAQqC,QAAQC,WACvBtC,EAAQsB,MAAMiB,QAAU,OACxB7B,GAAQ,0BASM,SACpBV,EACAI,GAEA,gBAFAA,IAAAA,EAAUR,GAEHI,EAAQqC,QAAQC,WACnBG,EAAGzC,EAASI,GACZgC,EAAKpC,EAASI"}