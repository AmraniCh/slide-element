{"version":3,"file":"index.modern.js","sources":["../src/index.ts"],"sourcesContent":["import { Options, HeightValues, CallbackFunction } from \"./types\";\n\nconst defaultOptions: Options = {\n  duration: 0.25,\n  timingFunction: \"ease\",\n};\n\n/**\n * Add transition event listeners to given element.\n */\nconst addEventListeners = (\n  element: HTMLElement,\n  callback: CallbackFunction\n): void => {\n  element.addEventListener(\"transitionend\", callback);\n  element.addEventListener(\"transitioncancel\", callback);\n};\n\n/**\n * Remove transition event listeners from given element.\n */\nconst removeEventListeners = (\n  element: HTMLElement,\n  callback: CallbackFunction\n): void => {\n  element.removeEventListener(\"transitionend\", callback);\n  element.removeEventListener(\"transitioncancel\", callback);\n};\n\n/**\n * Fire a one-time function when an animation has completed.\n */\nconst waitForAnimationCompletion = (element: HTMLElement): Promise<void> => {\n  return new Promise((resolve) => {\n    const eventListenerCallback = function (e: TransitionEvent): void {\n      removeEventListeners(element, eventListenerCallback);\n      resolve();\n    };\n\n    addEventListeners(element, eventListenerCallback);\n  });\n};\n\n/**\n * Reset the given style properties on an element.\n */\nconst unsetProperties = (\n  element: HTMLElement,\n  properties: Array<string>\n): void => {\n  properties.forEach((p: string) => (element.style[p] = \"\"));\n};\n\n/**\n * Set initial CSS required to perform height transition.\n */\nconst setTransitionProperties = (\n  element: HTMLElement,\n  options: Options\n): void => {\n  const computedStyle = getStyles(element);\n  const { duration, timingFunction } = options;\n  const animationStyles = {\n    overflow: \"hidden\",\n    transitionProperty: \"height\",\n    transitionDuration: `${duration}s`,\n    transitionTimingFunction: timingFunction,\n  };\n\n  /**\n   * Set these properties only if they aren't already set. If we blindly set them every run,\n   * the animation will not work as expected because a reflow is triggered.\n   */\n  for (let k in animationStyles) {\n    if (computedStyle[k] === animationStyles[k]) {\n      delete animationStyles[k];\n    }\n  }\n\n  Object.assign(element.style, animationStyles);\n};\n\n/**\n * Retrieve the computed styles for an element.\n */\nconst getStyles = (element: HTMLElement): CSSStyleDeclaration => {\n  return window.getComputedStyle(element);\n};\n\n/**\n * Given a bunch of before/after property values, trigger a CSS animation\n * before & after the next repaint.\n */\nconst triggerAnimation = (\n  element: HTMLElement,\n  options: object,\n  heightValues: HeightValues,\n  callback: () => any\n): void => {\n  const { from, to } = heightValues;\n  waitForAnimationCompletion(element).then(() => {\n    unsetProperties(element, [\n      \"height\",\n      \"overflow\",\n      \"transitionProperty\",\n      \"transitionDuration\",\n      \"transitionTimingFunction\",\n    ]);\n\n    callback();\n  });\n\n  element.style.height = from;\n\n  setTransitionProperties(element, options);\n\n  // This update must happen on a separate tick in order to trigger an animation.\n  requestAnimationFrame(() => {\n    requestAnimationFrame(() => {\n      element.style.height = to;\n    });\n  });\n};\n\n/**\n * Animate an element open.\n */\nexport const down = (\n  element: HTMLElement,\n  options = defaultOptions\n): Promise<boolean> => {\n  return new Promise((resolve) => {\n    element.dataset.isSlidOpen = \"true\";\n    element.style.display = \"block\";\n    const computedStyles = getStyles(element);\n    triggerAnimation(\n      element,\n      options,\n      {\n        from: \"0px\",\n        to: computedStyles.height,\n      },\n      () => {\n        resolve(true);\n      }\n    );\n  });\n};\n\n/**\n * Animate an element closed.\n */\nexport const up = (element, options = defaultOptions): Promise<boolean> => {\n  return new Promise((resolve) => {\n    const computedStyles = getStyles(element);\n    triggerAnimation(\n      element,\n      options,\n      {\n        from: computedStyles.height,\n        to: \"0px\",\n      },\n      () => {\n        delete element.dataset.isSlidOpen;\n        element.style.display = \"none\";\n        resolve(false);\n      }\n    );\n  });\n};\n\n/**\n * Animate an element open or closed based on its state.\n */\nexport const toggle = (\n  element: HTMLElement,\n  options = defaultOptions\n): Promise<boolean> => {\n  return element.dataset.isSlidOpen\n    ? up(element, options)\n    : down(element, options);\n};\n"],"names":["defaultOptions","duration","timingFunction","getStyles","element","window","getComputedStyle","triggerAnimation","options","heightValues","callback","from","to","Promise","resolve","addEventListener","addEventListeners","eventListenerCallback","e","removeEventListener","removeEventListeners","waitForAnimationCompletion","then","properties","forEach","p","style","unsetProperties","height","computedStyle","animationStyles","overflow","transitionProperty","transitionDuration","transitionTimingFunction","k","Object","assign","setTransitionProperties","requestAnimationFrame","down","dataset","isSlidOpen","display","computedStyles","up","toggle"],"mappings":"AAEA,MAAMA,EAA0B,CAC9BC,SAAU,IACVC,eAAgB,QAiFZC,EAAaC,GACVC,OAAOC,iBAAiBF,GAO3BG,EAAmB,CACvBH,EACAI,EACAC,EACAC,KAEA,MAAMC,KAAEA,EAAFC,GAAQA,GAAOH,EAnEaL,CAAAA,OACvBS,QAASC,IAvBI,EACxBV,EACAM,KAEAN,EAAQW,iBAAiB,gBAAiBL,GAC1CN,EAAQW,iBAAiB,mBAAoBL,IAwB3CM,CAAkBZ,EALY,SAAxBa,EAAkCC,GAbf,EAC3Bd,EACAM,KAEAN,EAAQe,oBAAoB,gBAAiBT,GAC7CN,EAAQe,oBAAoB,mBAAoBT,IAS5CU,CAAqBhB,EAASa,GAC9BH,QAgEJO,CAA2BjB,GAASkB,KAAK,KAtDnB,EACtBlB,EACAmB,KAqD2B,CACvB,SACA,WACA,qBACA,qBACA,4BAxDOC,QAASC,GAAerB,EAAQsB,MAAMD,GAAK,KAmDpDE,CAAgBvB,GAQhBM,MAGFN,EAAQsB,MAAME,OAASjB,EAxDO,EAC9BP,EACAI,KAEA,MAAMqB,EAAgB1B,EAAUC,IAC1BH,SAAEA,EAAFC,eAAYA,GAAmBM,EAC/BsB,EAAkB,CACtBC,SAAU,SACVC,mBAAoB,SACpBC,mBAAuBhC,MACvBiC,yBAA0BhC,GAO5B,IAAK,IAAIiC,KAAKL,EACRD,EAAcM,KAAOL,EAAgBK,WAChCL,EAAgBK,GAI3BC,OAAOC,OAAOjC,EAAQsB,MAAOI,IAmC7BQ,CAAwBlC,EAASI,GAGjC+B,sBAAsB,KACpBA,sBAAsB,KACpBnC,EAAQsB,MAAME,OAAShB,OAQhB4B,EAAO,CAClBpC,EACAI,EAAUR,QAECa,QAASC,IAClBV,EAAQqC,QAAQC,WAAa,OAC7BtC,EAAQsB,MAAMiB,QAAU,QACxB,MAAMC,EAAiBzC,EAAUC,GACjCG,EACEH,EACAI,EACA,CACEG,KAAM,MACNC,GAAIgC,EAAehB,QAErB,KACEd,GAAQ,OASH+B,EAAK,CAACzC,EAASI,EAAUR,QACzBa,QAASC,IAClB,MAAM8B,EAAiBzC,EAAUC,GACjCG,EACEH,EACAI,EACA,CACEG,KAAMiC,EAAehB,OACrBhB,GAAI,OAEN,YACSR,EAAQqC,QAAQC,WACvBtC,EAAQsB,MAAMiB,QAAU,OACxB7B,GAAQ,OASHgC,EAAS,CACpB1C,EACAI,EAAUR,IAEHI,EAAQqC,QAAQC,WACnBG,EAAGzC,EAASI,GACZgC,EAAKpC,EAASI"}